$Id: TODO,v 1.77 2005/11/09 13:53:49 bzforlow Exp $

- Code documentation:
   * spxdefines.h: DEFAULT_EPS_FACTOR, DEFAULT_EPS_UPDATE und Param dokumentieren
   * slufactor.h: document the two change methods ETA and FOREST_TOMLIN, uvam.
   * clufactor.h: ziemlich undokumentiert
   * solve2right4update (slinsolver.h/slufactor.cpp): solves Ax=b, Ay=d?
   * spxaggregatesm.h: ???
   * spxdataset.h: mehrmals "???". Ziemlich kranke Klasse...
   * spxbasis.h: removedRows, removedCols: correct documentation?
   * spxdevexpr.h: ziemlich undokumentiert
   * spxharrisrt.h: Was machen maxDelta() und minDelta()?
   * spxlp.h: obj(): This should return spxSense() * maxObj; returns objective
     vector. Wo ist das implementiert?
   * src/spxintervalsm.h: Da werden epsilon und delta für nicht-Null-Tests
     verwendet. Delta ist nicht dokumentiert.
   * src/spxparmultpr.h: nur mäßig dokumentiert.
   * src/spxredundantsm.h: private helpers nicht dokumentiert
   * src/spxscaler: Dokumentation fragwürdig: unscale() gibt es nicht (nur
     unscalePrimal() und unscaleDual()), passendes load() gibt es auch nicht.
   * spxsteeppr.h: Dokumentation der Daten unvollständig
   * spxvectorst.h: irgeneine Testversion. Behalten oder löschen?
   * spxvectorst.h: state == NONE means not working at all. Remove this state?
   
- spxbasis.h::solver(): "@todo Name should be changed, or loadSolver should be renamed."  Warum?
- spxdefaultpr.h: @todo This should be renamed to something like Danzig or Textbook pricing.
- factor.cpp: "??? mkwtz originally was long, maybe to avoid an overflow in this instruction?"
- spxchangebasis.cpp (2x): /* ??? I think, this cannot happen. */
- diverse "#ifdef USE_OLD"-Stellen -> grep

- Es wird infeasible/unbounded gemeldet je nach dem welcher algo 
  gerade am Laufen war.

- der col_first parameter bei scale wird nicht mehr benutzt.

Vermutlich sind die meisten solve() methoden in 
CLUFactor::solve.cpp const. Müßten von den Pointern
befreit werden

SSVector::multAdd() sollte von den pointern befreit werden.

simplifier sollten nicht unsimplify machen, sondern
uncrush_x und uncrush_pi, das LP kann man sich auch merken.

neos4, neos5 werden fälschlicherweise als infeasible gemeldet.

Diesen Kram mal als @todo's schreiben ;-)

Genau gucken, was spxredundantsm eigendlich macht. Das scheint mir
mehr ein bound strengthening zu sein.
Ich habe nicht den eindruck, das der doppelte Zeilen/Spalten finden
würde.

Einzel remove so implementieren, dass alles weitergeschoben wird.


Es gibt Probleme, wenn der Preprocessor das Problem komplett erledigt.
Denn die Rueckgabe ist dann nicht UNBOUNDED/INFEASIBLE, sondern fertig.

isConsistent sollte eigentlich virtuell sein.

Memberfunctionen .has -> bool

Abbruch bei minimieren mit Upper Bound

primal: >= UB und optimal
dual  : >= UB und shift = 0

---------------

spxbasis  load(xxx) umbennen in loadDesc, loadLP usw.

-----------------------------------------------------------------------------

bin/soplex.linux.x86.gnu.dbg-ld  -e -r check/LP/netlib/etamacro.mps

soplex.linux.x86.gnu.dbg-ld: src/spxvecs.cpp:240: void soplex::SoPlex::computeFrhs2(const soplex::Vector &, const soplex::Vector &): Assertion `colfb[i] == coufb[i]' failed.

240                 assert(colfb[i] == coufb[i]);
Current language:  auto; currently c++
(gdb) print i
$1 = 368
(gdb) print colfb[i]
$2 = 0
(gdb) print coufb[i]
$3 = -nan(0xc000000000000000)

kommt auch bei check.netlib.linux.x86.gnu.dbg

-----------------------------------------------------------------------------

nug12

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  ms/call  ms/call  name    
 41.26    400.98   400.98 41390449     0.01     0.01  soplex::CLUFactor::updateRow(int, int, int, int, double, double)
 10.33    501.40   100.42    45964     2.18     2.18  soplex::CLUFactor::vSolveLright2(double *, int *, int *, double, double *, int *, int

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 34.29   4791.24  4791.24 634306343     0.00     0.00  soplex::CLUFactor::updateRow(int, int, int, int, double, double)
 11.91   6455.54  1664.30   709664     0.00     0.00  soplex::CLUFactor::vSolveLright2(double *, int *, int *, double, double *, int *, int

-----------------------------------------------------------------------------


stdio.h/printf die letzten erlegen.

tester/simplifier usw. auch wie pricer mit namen versehen.

neue abstracte basisklasse spxscaler mit spxequilim=spxscale
als erste implementierung.
   DataArray < Real > colscale;  ///< column scaleing factors
   DataArray < Real > rowscale;  ///< row scaleing factors
kann in die basisklasse
Als unterscheid zu simplifier kommt noch ein
getObjValue(col) aufruf dazu, außerdem kann dann der scaler
gleichseitig mit dem simplifiern eingesetzt werden.

vsolve/solve/update isNotZero() benutzen

openMP insbesondere pricer/ratiotest (compaq,intel)
ewtl die enterX/leaveX funktionen inlinen.

cplexrun mit delta = 1e-9 für bessere werte in check.

Wir bräuchten ein Programm, das ein LP liest, eine Liste mit den 
Variablenwerten der Lösung von SoPlex und dann guckt ob die Bounds
stimmen usw. und so sagt ob die Lösung zulässig ist. Am besten mit
rationaler Arithmetik.

SVSet::memPack, vermutlichen bug in flexelint melden. this-> ist überflüssig.

BUG in spxscalesm.cc value() wird nicht descaliert. 
Entsprechender Aufruf fehlt auch in spxgeneralsm.cc

reinterpret_cast durchsehen

// lprow.cpp:double LPRow::infinity = 1e+100;
// spxlp.cpp:const double SPxLP::infinity = 1e+100;

Soplex1.1-Patch: keepBasis einfuehren fuer schnelles Reoptimieren
(siehe soplex-patch.txt)

Dokumentation: (alle * sind bereits fertig)

cring.h
clufactor.h
+slufactor.h  // hier fehlen noch ein paar Sachen  -> Thorsten!
+soplex.h // in Arbeit ;-)

sunos.sparc.sun LC 0 2494 14255
greenbea ER 
greenbeb ER

linux.alpha.compaq LC 0 542 3142
greenbea ER   =infeasible=
greenbeb LR   =infeasible=

linux.alpha.gnu LC 0 569 3399
greenbea LR
pilot-ja LR

osf1.alpha.compaq LC 0 522 2819
greenbeb ER
pilot    LR *
pilot87  ER

osf1.alpha.gnu LC 0 546 3286
greenbea LR 
pilot-ja LR

linux.x86.gnu LC 0 593 3209
greenbea ER 

hp-ux.hppa.hp LC 0 755 4626
greenbea LR
pilot-ja LR

irix.mips.sgi LC 0 6223 35624
greenbea LR
pilot-ja LR

linux.x86.intel LC 0 936 5121
greenbea ER







